#!/bin/sh
# List attribute KEYS for an AWS pricing "service" + "productFamily" in a region.
#
# Usage:
#   ./3_find_attribute_keys.sh "<Service>" "<ProductFamily>" [key=value ...]
#
# Examples:
#   ./3_find_attribute_keys.sh "AmazonRDS" "Database Instance"
#   ./3_find_attribute_keys.sh "AmazonEC2" "Compute Instance" preInstalledSw=NA operatingSystem=Linux
#
# Requirements: jq, and either gq or curl.
#
# Env overrides:
#   ENDPOINT=https://pricing.infracost.io/graphql
#   REGION=us-east-1

set -eu

: "${ENDPOINT:=https://pricing.infracost.io/graphql}"
: "${REGION:=us-east-1}"

if [ $# -lt 2 ]; then
  echo "Usage: $0 <Service> <ProductFamily> [key=value ...]" >&2
  exit 1
fi

SERVICE="$1"
PRODUCT_FAMILY="$2"
shift 2

need() {
  command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 1; }
}
need jq
# gq OR curl is fine

# Build attributes filter array from extra key=value args
ATTRS_JSON='[]'
while [ $# -gt 0 ]; do
  kv="$1"; shift
  k="${kv%%=*}"
  v="${kv#*=}"
  if [ -n "$k" ] && [ -n "$v" ] && [ "$k" != "$kv" ]; then
    ATTRS_JSON=$(printf '%s\n' "$ATTRS_JSON" | jq --arg k "$k" --arg v "$v" '. + [{key:$k, value:$v}]')
  fi
done

fetch() {
  if command -v gq >/dev/null 2>&1; then
    gq "$ENDPOINT" -q '
      query ($service: String!, $pf: String!, $region: String!, $attrs: [ProductAttributeFilter!]) {
        products(filter: {
          vendorName: "aws"
          region: $region
          service: $service
          productFamily: $pf
          attributes: $attrs
        }) {
          productHash
          attributes { key, value }
        }
      }
    ' -v service="$SERVICE" -v pf="$PRODUCT_FAMILY" -v region="$REGION" -v attrs="$ATTRS_JSON"
  else
    need curl
    QUERY='query ($service: String!, $pf: String!, $region: String!, $attrs: [ProductAttributeFilter!]) {
      products(filter: {
        vendorName: "aws"
        region: $region
        service: $service
        productFamily: $pf
        attributes: $attrs
      }) {
        productHash
        attributes { key, value }
      }
    }'
    BODY=$(jq -nc \
      --arg q "$QUERY" \
      --arg s "$SERVICE" \
      --arg pf "$PRODUCT_FAMILY" \
      --arg r "$REGION" \
      --argjson attrs "$ATTRS_JSON" \
      '{query:$q, variables:{service:$s, pf:$pf, region:$r, attrs:$attrs}}')
    curl -sS -X POST "$ENDPOINT" -H "Content-Type: application/json" -d "$BODY"
  fi
}

RESP="$(fetch)"

# GraphQL errors?
if [ "$(echo "$RESP" | jq 'has("errors")')" = "true" ]; then
  echo "GraphQL returned errors:" >&2
  echo "$RESP" | jq '.errors' >&2
  exit 1
fi

# Aggregate keys and detect uniqueness of product
echo "$RESP" | jq -r '
  .data.products as $p
  | if ($p | length) == 0 then
      { _note:"NO_MATCH" }
    elif ($p | length) == 1 then
      {
        _note: "UNIQUE",
        productHash: ($p[0].productHash // ""),
        keys: (
          ($p[0].attributes // [])
          | map(.key // empty)
          | unique
          | sort
        )
      }
    else
      {
        _note: "MULTI",
        count: ($p | length),
        keys: (
          $p
          | map(.attributes // [])
          | flatten
          | map(.key // empty)
          | unique
          | sort
        )
      }
    end
' | {
  read_json() {
    jq -r "$1"
  }
  JSON="$(cat)"
  NOTE=$(printf '%s' "$JSON" | read_json '._note')
  case "$NOTE" in
    "NO_MATCH")
      echo "No products matched your filters."
      echo "  service       = $SERVICE"
      echo "  productFamily = $PRODUCT_FAMILY"
      echo "  region        = $REGION"
      exit 2
      ;;
    "UNIQUE")
      PH=$(printf '%s' "$JSON" | read_json '.productHash')
      echo "Unique product found."
      echo "productHash: $PH"
      echo ""
      echo "Attribute keys:"
      printf '%s' "$JSON" | jq -r '.keys[]'
      ;;
    "MULTI")
      CNT=$(printf '%s' "$JSON" | read_json '.count')
      echo "Found $CNT matching products."
      echo ""
      echo "Attribute keys (unique):"
      printf '%s' "$JSON" | jq -r '.keys[]'
      ;;
    *)
      echo "Unexpected parser state." >&2
      printf '%s\n' "$JSON" | jq >&2
      exit 1
      ;;
  esac
}
